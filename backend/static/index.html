<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>{{SITE_TITLE}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="{{SITE_DESCRIPTION}}" />
  <link rel="icon" href="{{SITE_ICON}}" type="image/png" />
  <meta property="og:title" content="{{SITE_TITLE}}" />
  <meta property="og:description" content="{{SITE_DESCRIPTION}}" />
  <meta property="og:type" content="website" />
  {{OG_IMAGE_TAG}}
  <meta property="og:url" content="{{SITE_URL}}" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="{{SITE_TITLE}}" />
  <meta name="twitter:description" content="{{SITE_DESCRIPTION}}" />
  {{TWITTER_IMAGE_TAG}}
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    .hud {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,.65);
      color: #fff;
      padding: 10px 12px;
      border-radius: 10px;
      font-family: ui-sans-serif, system-ui, sans-serif;
      z-index: 999;
      max-width: 340px;
    }
    .hud-header { display: flex; align-items: center; gap: 8px; }
    .small { opacity: .85; font-size: 12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background: rgba(255,255,255,.12); margin-right:6px; }
    .legend { margin-top: 8px; display: grid; gap: 6px; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-size: 12px; opacity: 0.9; }
    .legend-line { width: 30px; height: 0; border-top: 4px solid; display: inline-block; }
    .legend-trace { border-color: #ff7a1a; border-top-style: dashed; }
    .legend-message { border-color: #2b8cff; border-top-style: solid; }
    .legend-advert { border-color: #2ecc71; border-top-style: dotted; }
    .legend-los-clear { border-color: #22c55e; border-top-style: solid; }
    .legend-los-blocked { border-color: #ef4444; border-top-style: dashed; }
    .legend-dot { width: 12px; height: 12px; border-radius: 50%; border: 2px solid; display: inline-block; }
    .legend-repeater { border-color: #1d4ed8; background: #2b8cff; }
    .legend-companion { border-color: #6b21a8; background: #a855f7; }
    .legend-room { border-color: #b45309; background: #f59e0b; }
    .legend-unknown { border-color: #4b5563; background: #d1d5db; }
    .legend-heat { width: 30px; height: 10px; border-radius: 6px; background: linear-gradient(90deg, #fbbf24, #f97316, #ef4444, #b91c1c); border: 1px solid rgba(255,255,255,.25); display: inline-block; }
    .legend-toggle {
      margin-top: 6px;
      font-size: 12px;
      background: rgba(255,255,255,.12);
      color: #fff;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .legend-collapsed .legend { display: none; }
    .map-toggle {
      margin-top: 6px;
      font-size: 12px;
      background: rgba(255,255,255,.12);
      color: #fff;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .map-toggle.active {
      background: rgba(34,197,94,.35);
      border-color: rgba(34,197,94,.6);
    }
    .prop-panel {
      margin-top: 6px;
      padding: 8px;
      border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.18);
      display: none;
      gap: 6px;
    }
    .prop-panel.active { display: grid; }
    .prop-field {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
    }
    .prop-panel input,
    .prop-panel select {
      background: rgba(0,0,0,.35);
      color: #fff;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 12px;
    }
    .prop-panel input[type="range"] {
      padding: 0;
      accent-color: #22c55e;
      width: 120px;
    }
    .prop-panel input[type="number"] {
      width: 70px;
    }
    .prop-panel select {
      width: 150px;
    }
    .prop-hint {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      margin-left: 6px;
      color: #cbd5f5;
      cursor: help;
      font-weight: 600;
    }
    .prop-hint::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 18px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(15, 23, 42, 0.95);
      color: #fff;
      padding: 4px 6px;
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      transition: opacity 120ms ease;
    }
    .prop-hint:hover::after,
    .prop-hint:focus::after {
      opacity: 1;
    }
    .leaflet-popup-content { max-width: 260px; overflow-wrap: anywhere; word-break: break-word; }
    .popup-title { display: block; font-weight: 600; }
    .popup-id { display: block; opacity: 0.85; }
    .popup-topic { display: inline-block; overflow-wrap: anywhere; word-break: break-word; }
    .trail-animated {
      stroke-dasharray: 6 10;
      animation: trail-dash 6s linear infinite;
    }
    @keyframes trail-dash {
      to { stroke-dashoffset: -120; }
    }
    .route-animated {
      stroke-dasharray: 12 18;
      animation: route-dash 8s linear infinite;
      stroke-linecap: butt;
      stroke-linejoin: miter;
    }
    @keyframes route-dash {
      to { stroke-dashoffset: -200; }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-header">
      <div><span class="pill">Live</span> {{SITE_TITLE}}</div>
    </div>
    <div class="small">Markers update in real time. Trails show last ~50 points.</div>
    <div class="small">{{SITE_FEED_NOTE}}</div>
    <div class="small" id="stats"></div>
    <div class="small" id="los-status"></div>
    <button class="legend-toggle" id="legend-toggle" type="button">Hide legend</button>
    <button class="map-toggle" id="map-toggle" type="button">Dark map</button>
    <button class="map-toggle" id="topo-toggle" type="button">Topo map</button>
    <button class="map-toggle" id="los-toggle" type="button">LOS tool</button>
    <button class="map-toggle" id="prop-toggle" type="button">Propagation</button>
    <button class="map-toggle" id="nodes-toggle" type="button">Hide nodes</button>
    <div class="prop-panel" id="prop-panel">
      <div class="small"><strong>Propagation estimate</strong></div>
      <div class="small">LoRa 910.525 MHz • BW 62.5 kHz • SF7 • CR8</div>
      <div class="small">Assumes 6 dB noise figure and 10 dB fade margin.</div>
      <div class="small">Defaults assume 5 m AGL; MSL overrides use terrain data.</div>
      <label class="prop-field">
        <span>Tx power (dBm)<span class="prop-hint" title="transmit power used for link budget" data-tooltip="transmit power used for link budget">?</span></span>
        <input id="prop-txpower" type="number" min="2" max="30" step="1" value="22" />
      </label>
      <label class="prop-field">
        <span>Opacity<span class="prop-hint" title="overlay transparency" data-tooltip="overlay transparency">?</span></span>
        <input id="prop-opacity" type="range" min="0.05" max="0.6" step="0.05" value="0.2" />
      </label>
      <label class="prop-field">
        <span>Model<span class="prop-hint" title="path-loss environment profile (best-case matches the Meshcore app)" data-tooltip="path-loss environment profile (best-case matches the Meshcore app)">?</span></span>
        <select id="prop-model">
          <option value="free" selected>Best-case (free-space)</option>
          <option value="suburban">Suburban</option>
          <option value="urban">Urban</option>
          <option value="indoor">Indoor/obstructed</option>
        </select>
      </label>
      <label class="prop-field">
        <span>Terrain adjust<span class="prop-hint" title="apply terrain diffraction using elevation tiles" data-tooltip="apply terrain diffraction using elevation tiles">?</span></span>
        <input id="prop-terrain" type="checkbox" checked />
      </label>
      <label class="prop-field">
        <span>Tx AGL (m)<span class="prop-hint" title="transmitter height above ground" data-tooltip="transmitter height above ground">?</span></span>
        <input id="prop-tx-agl" type="number" min="0" max="50" step="0.5" value="5" />
      </label>
      <label class="prop-field">
        <span>Tx MSL override (m)<span class="prop-hint" title="override transmitter altitude above sea level" data-tooltip="override transmitter altitude above sea level">?</span></span>
        <input id="prop-tx-msl" type="number" min="-100" max="9000" step="1" placeholder="auto" />
      </label>
      <label class="prop-field">
        <span>Rx AGL (m)<span class="prop-hint" title="receiver height above ground" data-tooltip="receiver height above ground">?</span></span>
        <input id="prop-rx-agl" type="number" min="0" max="50" step="0.5" value="5" />
      </label>
      <label class="prop-field">
        <span>Rx MSL override (m)<span class="prop-hint" title="override receiver altitude above sea level" data-tooltip="override receiver altitude above sea level">?</span></span>
        <input id="prop-rx-msl" type="number" min="-100" max="9000" step="1" placeholder="auto" />
      </label>
      <label class="prop-field">
        <span>Min Rx cutoff (dBm)<span class="prop-hint" title="enter your SNR value here" data-tooltip="enter your SNR value here">?</span></span>
        <input id="prop-min-rx" type="number" min="-150" max="-60" step="1" value="-97" />
      </label>
      <label class="prop-field">
        <span>Auto range (cutoff)<span class="prop-hint" title="derive range from min Rx cutoff" data-tooltip="derive range from min Rx cutoff">?</span></span>
        <input id="prop-auto-range" type="checkbox" checked />
      </label>
      <label class="prop-field">
        <span>Multi-origin<span class="prop-hint" title="allow multiple transmitters in one render" data-tooltip="allow multiple transmitters in one render">?</span></span>
        <input id="prop-multi-origin" type="checkbox" checked />
      </label>
      <label class="prop-field">
        <span>Fade by margin<span class="prop-hint" title="fade coverage by link margin strength" data-tooltip="fade coverage by link margin strength">?</span></span>
        <input id="prop-fade-margin" type="checkbox" />
      </label>
      <button class="map-toggle" id="prop-clear-origins" type="button">Clear origins</button>
      <label class="prop-field">
        <span>Auto resolution<span class="prop-hint" title="scale grid to stay within target cells" data-tooltip="scale grid to stay within target cells">?</span></span>
        <input id="prop-auto-res" type="checkbox" checked />
      </label>
      <label class="prop-field">
        <span>Target cells<span class="prop-hint" title="upper bound for grid cell count" data-tooltip="upper bound for grid cell count">?</span></span>
        <input id="prop-max-cells" type="number" min="20000" max="500000" step="10000" value="120000" />
      </label>
      <label class="prop-field">
        <span>Grid step (m)<span class="prop-hint" title="spacing between coverage samples" data-tooltip="spacing between coverage samples">?</span></span>
        <input id="prop-grid" type="number" min="30" max="300" step="10" value="90" />
      </label>
      <label class="prop-field">
        <span>Sample step (m)<span class="prop-hint" title="terrain sampling interval along each ray" data-tooltip="terrain sampling interval along each ray">?</span></span>
        <input id="prop-sample" type="number" min="30" max="300" step="10" value="90" />
      </label>
      <label class="prop-field">
        <span>Range factor<span class="prop-hint" title="scale the base range estimate" data-tooltip="scale the base range estimate">?</span></span>
        <input id="prop-range-factor" type="range" min="0.25" max="1" step="0.05" value="1" />
      </label>
      <button class="map-toggle" id="prop-render" type="button">Render prop</button>
      <div class="small" id="prop-range"></div>
      <div class="small" id="prop-cost"></div>
      <div class="small" id="prop-status"></div>
    </div>
    <div class="legend">
      <div class="legend-item"><span class="legend-line legend-trace"></span> Trace/path</div>
      <div class="legend-item"><span class="legend-line legend-message"></span> Message</div>
      <div class="legend-item"><span class="legend-line legend-advert"></span> Advert</div>
      <div class="legend-item"><span class="legend-line legend-los-clear"></span> LOS clear</div>
      <div class="legend-item"><span class="legend-line legend-los-blocked"></span> LOS blocked</div>
      <div class="legend-item"><span class="legend-heat"></span> Heat (last 10 min)</div>
      <div class="legend-item"><span class="legend-dot legend-repeater"></span> Repeater</div>
      <div class="legend-item"><span class="legend-dot legend-companion"></span> Companion</div>
      <div class="legend-item"><span class="legend-dot legend-room"></span> Room server</div>
      <div class="legend-item"><span class="legend-dot legend-unknown"></span> Unknown</div>
    </div>
  </div>
  <div id="map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <script>
    const map = L.map('map', { zoomControl: false }).setView([42.3601, -71.1500], 10); // default Boston-ish
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    const lightTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
    });
    const topoTiles = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
      maxZoom: 17,
      attribution: '&copy; OpenStreetMap contributors &copy; OpenTopoMap'
    });
    let baseLayer = 'light';
    const storedLayer = localStorage.getItem('meshmapBaseLayer');
    if (storedLayer === 'dark' || storedLayer === 'topo' || storedLayer === 'light') {
      baseLayer = storedLayer;
    }

    const markers = new Map();   // device_id -> Leaflet marker
    const polylines = new Map(); // device_id -> Leaflet polyline
    const nodeLayer = L.layerGroup().addTo(map);
    let nodesVisible = true;
    const routeLines = new Map(); // route_id -> { line, timeout }
    const deviceMeta = new Map(); // device_id -> { lat, lon, name }
    const routeLayer = L.layerGroup().addTo(map);
    const heatLayer = L.heatLayer([], {
      radius: 28,
      blur: 22,
      minOpacity: 0.2,
      maxZoom: 16,
      gradient: { 0.2: '#fbbf24', 0.5: '#f97316', 0.8: '#ef4444', 1.0: '#b91c1c' }
    }).addTo(map);
    const heatPoints = [];
    const HEAT_TTL_MS = 10 * 60 * 1000;
    const losLayer = L.layerGroup().addTo(map);
    let losActive = false;
    let losPoints = [];
    let losLine = null;
    let losSuggestion = null;

    const propagationLayer = L.layerGroup().addTo(map);
    let propagationActive = false;
    let propagationOrigins = [];
    let propagationOriginMarkers = new Map();
    let propagationOriginSeq = 0;
    let propagationRaster = null;
    let propagationRasterCanvas = null;
    let propagationRasterMeta = null;
    let propagationBaseRange = null;
    let propagationNeedsRender = false;
    let propagationRenderInFlight = false;
    let propagationComputeToken = 0;
    let propagationWorker = null;
    let propagationLastConfig = null;

    const PROP_DEFAULTS = {
      freqMHz: 910.525,
      bwHz: 62500,
      sf: 7,
      cr: 8,
      snrMinDb: -7.5,
      noiseFigureDb: 6,
      fadeMarginDb: 10,
      fresnelFactor: 0.2
    };

    const PROP_TERRARIUM_URL = 'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png';

    const PROP_MODELS = {
      free: { label: 'Best-case (free-space)', n: 2.0, clutterLossDb: 0 },
      suburban: { label: 'Suburban', n: 2.2, clutterLossDb: 6 },
      urban: { label: 'Urban', n: 2.3, clutterLossDb: 10 },
      indoor: { label: 'Indoor/obstructed', n: 2.7, clutterLossDb: 18 }
    };

    function resolveRole(d) {
      const role = (d.role || '').toLowerCase();
      if (role.includes('repeater')) return 'repeater';
      if (role.includes('companion')) return 'companion';
      if (role.includes('room')) return 'room';
      return 'unknown';
    }

    function markerStyleForRole(role) {
      if (role === 'repeater') {
        return { color: '#1d4ed8', fillColor: '#2b8cff', fillOpacity: 0.95, radius: 8, weight: 2 };
      }
      if (role === 'companion') {
        return { color: '#6b21a8', fillColor: '#a855f7', fillOpacity: 0.95, radius: 8, weight: 2 };
      }
      if (role === 'room') {
        return { color: '#b45309', fillColor: '#f59e0b', fillOpacity: 0.95, radius: 8, weight: 2 };
      }
      return { color: '#4b5563', fillColor: '#d1d5db', fillOpacity: 0.95, radius: 8, weight: 2 };
    }

    function setStats() {
      document.getElementById('stats').textContent = `${markers.size} active devices • ${routeLines.size} routes`;
    }

    function setNodesVisible(visible) {
      nodesVisible = visible;
      const btn = document.getElementById('nodes-toggle');
      if (btn) {
        btn.classList.toggle('active', !visible);
        btn.textContent = visible ? 'Hide nodes' : 'Show nodes';
      }
      if (visible) {
        if (!map.hasLayer(nodeLayer)) {
          nodeLayer.addTo(map);
        }
      } else if (map.hasLayer(nodeLayer)) {
        map.removeLayer(nodeLayer);
      }
    }

    function setLosStatus(text) {
      const el = document.getElementById('los-status');
      if (el) {
        el.textContent = text || '';
      }
    }

    function setPropStatus(text) {
      const el = document.getElementById('prop-status');
      if (el) {
        el.textContent = text || '';
      }
    }

    function setPropRange(text) {
      const el = document.getElementById('prop-range');
      if (el) {
        el.textContent = text || '';
      }
    }

    function setPropCost(text) {
      const el = document.getElementById('prop-cost');
      if (el) {
        el.textContent = text || '';
      }
    }

    function clearLos() {
      losPoints = [];
      losLine = null;
      losSuggestion = null;
      losLayer.clearLayers();
      setLosStatus('');
    }

    function setLosActive(active) {
      losActive = active;
      const btn = document.getElementById('los-toggle');
      if (btn) {
        btn.classList.toggle('active', active);
        btn.textContent = active ? 'LOS: click 2 points' : 'LOS tool';
      }
      if (!active) {
        clearLos();
      } else {
        setLosStatus('LOS: select first point (Shift+click nodes too)');
      }
    }

    function resetPropagationRaster() {
      if (propagationRaster) {
        propagationLayer.removeLayer(propagationRaster);
        propagationRaster = null;
      }
      propagationRasterCanvas = null;
      propagationRasterMeta = null;
      if (propagationRenderInFlight) {
        propagationComputeToken += 1;
        propagationRenderInFlight = false;
      }
    }

    function clearPropagation() {
      clearPropagationOrigins();
      resetPropagationRaster();
      propagationBaseRange = null;
      propagationNeedsRender = false;
      propagationRenderInFlight = false;
      propagationComputeToken += 1;
      setPropRange('');
      setPropCost('');
      setPropStatus('');
    }

    function setPropActive(active) {
      propagationActive = active;
      const btn = document.getElementById('prop-toggle');
      const panel = document.getElementById('prop-panel');
      if (btn) {
        btn.classList.toggle('active', active);
        btn.textContent = active ? 'Propagation: select node(s)' : 'Propagation';
      }
      if (panel) {
        panel.classList.toggle('active', active);
      }
      if (!active) {
        clearPropagation();
      } else {
        setPropStatus('Select a node or click the map to set a transmitter.');
      }
    }

    function calcReceiverSensitivityDbm(bwHz, noiseFigureDb, snrMinDb) {
      return -174 + (10 * Math.log10(bwHz)) + noiseFigureDb + snrMinDb;
    }

    function calcFsplAt1mDb(freqMHz) {
      return 32.44 + (20 * Math.log10(freqMHz)) - 60;
    }

    function calcMaxPathLossDb(txPowerDbm, sensitivityDbm, fadeMarginDb) {
      return txPowerDbm - sensitivityDbm - fadeMarginDb;
    }

    function calcRangeMeters(maxPathLossDb, freqMHz, pathLossExponent, clutterLossDb) {
      const n = Math.max(1.5, pathLossExponent);
      const fspl1m = calcFsplAt1mDb(freqMHz);
      const lossBudget = maxPathLossDb - fspl1m - (Number.isFinite(clutterLossDb) ? clutterLossDb : 0);
      const exponent = lossBudget / (10 * n);
      return Math.max(1, Math.pow(10, exponent));
    }

    function formatDistance(meters) {
      if (!Number.isFinite(meters)) return 'unknown';
      if (meters >= 1000) return `${(meters / 1000).toFixed(2)} km`;
      return `${Math.round(meters)} m`;
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const toRad = (deg) => deg * (Math.PI / 180);
      const r = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2
        + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return r * c;
    }

    function parseOptionalNumber(value) {
      if (value == null) return null;
      const trimmed = String(value).trim();
      if (trimmed === '') return null;
      const num = Number(trimmed);
      return Number.isFinite(num) ? num : null;
    }

    function formatNumber(value) {
      if (!Number.isFinite(value)) return '0';
      return value.toLocaleString(undefined, { maximumFractionDigits: 0 });
    }

    function isMultiOriginEnabled() {
      const input = document.getElementById('prop-multi-origin');
      return input ? input.checked : false;
    }

    function getPropagationConfig() {
      const txInput = document.getElementById('prop-txpower');
      const opacityInput = document.getElementById('prop-opacity');
      const modelSelect = document.getElementById('prop-model');
      const terrainInput = document.getElementById('prop-terrain');
      const txAglInput = document.getElementById('prop-tx-agl');
      const rxAglInput = document.getElementById('prop-rx-agl');
      const txMslInput = document.getElementById('prop-tx-msl');
      const rxMslInput = document.getElementById('prop-rx-msl');
      const minRxInput = document.getElementById('prop-min-rx');
      const autoRangeInput = document.getElementById('prop-auto-range');
      const fadeMarginInput = document.getElementById('prop-fade-margin');
      const autoResInput = document.getElementById('prop-auto-res');
      const maxCellsInput = document.getElementById('prop-max-cells');
      const gridInput = document.getElementById('prop-grid');
      const sampleInput = document.getElementById('prop-sample');
      const rangeFactorInput = document.getElementById('prop-range-factor');
      if (!txInput || !opacityInput || !modelSelect || !terrainInput || !txAglInput || !rxAglInput || !txMslInput || !rxMslInput || !minRxInput || !autoRangeInput || !fadeMarginInput || !autoResInput || !maxCellsInput || !gridInput || !sampleInput || !rangeFactorInput) {
        return null;
      }
      const txPower = Number(txInput.value);
      const opacity = Number(opacityInput.value);
      const model = PROP_MODELS[modelSelect.value] || PROP_MODELS.suburban;
      const terrain = terrainInput.checked;
      const txAgl = Number(txAglInput.value);
      const rxAgl = Number(rxAglInput.value);
      const txMsl = parseOptionalNumber(txMslInput.value);
      const rxMsl = parseOptionalNumber(rxMslInput.value);
      const minRxDbm = Number(minRxInput.value);
      const autoRange = autoRangeInput.checked;
      const fadeMargin = fadeMarginInput.checked;
      const autoResolution = autoResInput.checked;
      const maxCells = Number(maxCellsInput.value);
      const gridStep = Number(gridInput.value);
      const sampleStep = Number(sampleInput.value);
      const rangeFactor = Number(rangeFactorInput.value);
      if (!Number.isFinite(txPower) || !Number.isFinite(opacity)) return null;
      return {
        txPower,
        opacity: Math.min(0.9, Math.max(0.05, opacity)),
        model,
        terrain,
        gridStep: Number.isFinite(gridStep) ? Math.max(30, gridStep) : 90,
        sampleStep: Number.isFinite(sampleStep) ? Math.max(30, sampleStep) : 90,
        rangeFactor: Number.isFinite(rangeFactor) ? Math.min(1, Math.max(0.25, rangeFactor)) : 1,
        txAgl: Number.isFinite(txAgl) ? Math.max(0, txAgl) : 0,
        rxAgl: Number.isFinite(rxAgl) ? Math.max(0, rxAgl) : 0,
        minRxDbm: Number.isFinite(minRxDbm) ? Math.min(-60, Math.max(-150, minRxDbm)) : -97,
        autoRange,
        fadeMargin,
        autoResolution,
        maxCells: Number.isFinite(maxCells) ? Math.min(500000, Math.max(20000, maxCells)) : 120000,
        txMsl,
        rxMsl
      };
    }

    function estimatePropagationCost(renderRange, gridStep, sampleStep, originCount) {
      const latScale = 111320;
      const refLat = propagationOrigins.length
        ? (propagationOrigins.reduce((sum, origin) => sum + origin.lat, 0) / propagationOrigins.length)
        : map.getCenter().lat;
      const lonScale = 111320 * Math.cos(refLat * (Math.PI / 180));
      const rows = Math.max(1, Math.ceil((renderRange * 2) / gridStep));
      const cols = Math.max(1, Math.ceil((renderRange * 2) / (gridStep * (lonScale / latScale))));
      const cells = rows * cols;
      const avgSamples = Math.max(2, Math.ceil(renderRange / sampleStep) + 1);
      const multiplier = Math.max(1, originCount || 1);
      return {
        cells,
        samples: Math.round(cells * avgSamples * multiplier)
      };
    }

    function derivePropagationResolution(config, renderRange, originCount) {
      const originFactor = Math.max(1, originCount || 1);
      let gridStep = config.gridStep;
      let sampleStep = config.sampleStep;
      let estimate = estimatePropagationCost(renderRange, gridStep, sampleStep, originFactor);
      if (config.autoResolution && estimate.cells > (config.maxCells / originFactor)) {
        const scale = Math.sqrt(estimate.cells / (config.maxCells / originFactor));
        gridStep = Math.min(600, Math.max(30, Math.round((gridStep * scale) / 5) * 5));
        sampleStep = Math.min(600, Math.max(30, Math.round((sampleStep * scale) / 5) * 5));
        estimate = estimatePropagationCost(renderRange, gridStep, sampleStep, originFactor);
      }
      return {
        gridStep,
        sampleStep,
        cells: estimate.cells,
        samples: estimate.samples
      };
    }

    function getPropagationOriginKey(origin) {
      return origin.id || origin.key;
    }

    function clearPropagationOrigins() {
      propagationOrigins = [];
      propagationOriginMarkers.forEach((marker) => {
        propagationLayer.removeLayer(marker);
      });
      propagationOriginMarkers.clear();
    }

    function upsertPropagationOriginMarker(origin) {
      const key = getPropagationOriginKey(origin);
      if (!key) return;
      if (!propagationOriginMarkers.has(key)) {
        const marker = L.circleMarker([origin.lat, origin.lon], {
          radius: 5,
          color: '#22c55e',
          fillColor: '#22c55e',
          fillOpacity: 0.95,
          weight: 2
        }).addTo(propagationLayer);
        propagationOriginMarkers.set(key, marker);
      } else {
        const marker = propagationOriginMarkers.get(key);
        marker.setLatLng([origin.lat, origin.lon]);
      }
    }

    function isNodeCoveredByRaster(lat, lon, meta) {
      if (!meta) return false;
      if (!meta.coverage) return false;
      if (lat < meta.latMin || lat > meta.latMax || lon < meta.lonMin || lon > meta.lonMax) {
        return false;
      }
      const row = Math.floor((meta.latMax - lat) / meta.latStep);
      const col = Math.floor((lon - meta.lonMin) / meta.lonStep);
      if (row < 0 || col < 0 || row >= meta.rows || col >= meta.cols) return false;
      return meta.coverage[(row * meta.cols) + col] > 0;
    }

    function listLikelyNodesFromRaster() {
      const matches = [];
      if (!propagationOrigins.length) return matches;
      deviceMeta.forEach((meta, id) => {
        if (!meta || meta.lat == null || meta.lon == null) return;
        if (propagationOrigins.some((origin) => origin.id === id)) return;
        if (propagationRasterMeta && isNodeCoveredByRaster(meta.lat, meta.lon, propagationRasterMeta)) {
          let dist = Infinity;
          propagationOrigins.forEach((origin) => {
            const candidate = haversineMeters(origin.lat, origin.lon, meta.lat, meta.lon);
            if (candidate < dist) dist = candidate;
          });
          const label = meta.name ? meta.name : `${id.slice(0, 8)}...`;
          matches.push({ id, label, dist });
        }
      });
      matches.sort((a, b) => a.dist - b.dist);
      return matches;
    }

    function updatePropagationStatusFromRaster() {
      const likely = listLikelyNodesFromRaster();
      const count = likely.length;
      let status = `Likely to hit ${count} node${count === 1 ? '' : 's'}`;
      if (count > 0) {
        const names = likely.slice(0, 5).map(item => item.label).join(', ');
        status += `: ${names}`;
        if (count > 5) status += ` +${count - 5} more`;
      }
      setPropStatus(status);
    }

    function updatePropagationSummary() {
      const config = getPropagationConfig();
      if (!config) return;
      const sensitivity = calcReceiverSensitivityDbm(
        PROP_DEFAULTS.bwHz,
        PROP_DEFAULTS.noiseFigureDb,
        PROP_DEFAULTS.snrMinDb
      );
      const maxPathLoss = config.autoRange
        ? (config.txPower - config.minRxDbm)
        : calcMaxPathLossDb(config.txPower, sensitivity, PROP_DEFAULTS.fadeMarginDb);
      const baseRange = calcRangeMeters(maxPathLoss, PROP_DEFAULTS.freqMHz, config.model.n, config.model.clutterLossDb);
      propagationBaseRange = baseRange;
      const renderRange = config.autoRange ? baseRange : (baseRange * config.rangeFactor);
      const clutterNote = config.model.clutterLossDb ? ` +${config.model.clutterLossDb} dB clutter` : '';
      const cutoffNote = config.autoRange ? ` • cutoff ${config.minRxDbm} dBm` : '';
      setPropRange(`Range: ${formatDistance(renderRange)} (base ${formatDistance(baseRange)} • ${config.model.label}${clutterNote}${cutoffNote})`);
      const originCount = propagationOrigins.length;
      const resolution = derivePropagationResolution(config, renderRange, Math.max(1, originCount));
      const resLabel = config.autoResolution ? 'auto ' : '';
      const originLabel = originCount > 1 ? ` • ${originCount} origins` : (originCount === 1 ? ' • 1 origin' : '');
      setPropCost(`Estimate: ${formatNumber(resolution.cells)} cells • ${formatNumber(resolution.samples)} samples (${resLabel}grid ${formatNumber(resolution.gridStep)}m • sample ${formatNumber(resolution.sampleStep)}m${originLabel})`);
    }

    function markPropagationDirty(message) {
      propagationNeedsRender = true;
      if (message) {
        setPropStatus(message);
      } else if (propagationActive && propagationOrigins.length) {
        setPropStatus('Settings changed. Click "Render prop" to update.');
      }
    }

    function ensurePropagationWorker() {
      if (propagationWorker) return propagationWorker;
      const workerCode = [
        `const TILE_URL = ${JSON.stringify(PROP_TERRARIUM_URL)};`,
        'const TILE_SIZE = 256;',
        'const tileCache = new Map();',
        'function clamp(value, min, max) { return Math.min(max, Math.max(min, value)); }',
        'function lonLatToTile(lon, lat, zoom) {',
        '  const latRad = lat * Math.PI / 180;',
        '  const n = Math.pow(2, zoom);',
        '  const x = n * ((lon + 180) / 360);',
        '  const y = n * (1 - (Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI)) / 2;',
        '  const tileX = Math.floor(x);',
        '  const tileY = Math.floor(y);',
        '  const px = Math.floor((x - tileX) * TILE_SIZE);',
        '  const py = Math.floor((y - tileY) * TILE_SIZE);',
        '  return { tileX, tileY, px: clamp(px, 0, TILE_SIZE - 1), py: clamp(py, 0, TILE_SIZE - 1) };',
        '}',
        'async function fetchTile(z, x, y) {',
        '  const n = Math.pow(2, z);',
        '  if (x < 0 || y < 0 || x >= n || y >= n) return null;',
        '  const key = `${z}/${x}/${y}`;',
        '  if (tileCache.has(key)) return tileCache.get(key);',
        '  const url = TILE_URL.replace("{z}", z).replace("{x}", x).replace("{y}", y);',
        '  try {',
        '    const res = await fetch(url);',
        '    if (!res.ok) { tileCache.set(key, null); return null; }',
        '    const blob = await res.blob();',
        '    const bitmap = await createImageBitmap(blob);',
        '    const canvas = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);',
        '    const ctx = canvas.getContext("2d");',
        '    ctx.drawImage(bitmap, 0, 0);',
        '    const data = ctx.getImageData(0, 0, TILE_SIZE, TILE_SIZE).data;',
        '    tileCache.set(key, data);',
        '    return data;',
        '  } catch (err) {',
        '    tileCache.set(key, null);',
        '    return null;',
        '  }',
        '}',
        'async function getElevation(lat, lon, zoom) {',
        '  const coords = lonLatToTile(lon, lat, zoom);',
        '  const tile = await fetchTile(zoom, coords.tileX, coords.tileY);',
        '  if (!tile) return null;',
        '  const idx = (coords.py * TILE_SIZE + coords.px) * 4;',
        '  const r = tile[idx];',
        '  const g = tile[idx + 1];',
        '  const b = tile[idx + 2];',
        '  return (r * 256 + g + b / 256) - 32768;',
        '}',
        'function knifeEdgeLossFromV(v) {',
        '  if (!Number.isFinite(v) || v <= 0) return 0;',
        '  const loss = 6.9 + 20 * Math.log10(Math.sqrt((v - 0.1) ** 2 + 1) + v - 0.1);',
        '  return Math.max(0, loss);',
        '}',
        'self.onmessage = async (event) => {',
        '  const data = event.data;',
        '  if (!data || data.type !== "render") return;',
        '  const { token, origins, config, renderRange, maxPathLossDb, fspl1mDb, freqMHz } = data;',
        '  try {',
        '    if (!Array.isArray(origins) || origins.length === 0) {',
        '      throw new Error("No origins provided");',
        '    }',
        '  const latScale = 111320;',
        '  const refLat = origins.reduce((sum, o) => sum + o.lat, 0) / origins.length;',
        '  const lonScale = 111320 * Math.cos(refLat * Math.PI / 180);',
        '  const latStep = config.gridStep / latScale;',
        '  const lonStep = config.gridStep / lonScale;',
        '  let latMin = Infinity;',
        '  let latMax = -Infinity;',
        '  let lonMin = Infinity;',
        '  let lonMax = -Infinity;',
        '  for (const origin of origins) {',
        '    const originLonScale = 111320 * Math.cos(origin.lat * Math.PI / 180);',
        '    const latRadius = renderRange / latScale;',
        '    const lonRadius = renderRange / originLonScale;',
        '    latMin = Math.min(latMin, origin.lat - latRadius);',
        '    latMax = Math.max(latMax, origin.lat + latRadius);',
        '    lonMin = Math.min(lonMin, origin.lon - lonRadius);',
        '    lonMax = Math.max(lonMax, origin.lon + lonRadius);',
        '  }',
        '  const rows = Math.max(1, Math.ceil((latMax - latMin) / latStep));',
        '  const cols = Math.max(1, Math.ceil((lonMax - lonMin) / lonStep));',
        '  const zoom = clamp(Math.round(Math.log2(156543.03392 * Math.cos(refLat * Math.PI / 180) / config.gridStep)), 8, 12);',
        '  const lambda = 299792458 / (freqMHz * 1e6);',
        '  const clutterLossDb = Number.isFinite(config.clutterLossDb) ? config.clutterLossDb : 0;',
        '  const originEntries = [];',
        '  for (const origin of origins) {',
        '    const originGround = config.useTerrain && config.txMsl == null ? await getElevation(origin.lat, origin.lon, zoom) : 0;',
        '    const txAbs = (config.txMsl != null) ? config.txMsl : (originGround ?? 0) + config.txAgl;',
        '    originEntries.push({',
        '      lat: origin.lat,',
        '      lon: origin.lon,',
        '      lonScale: 111320 * Math.cos(origin.lat * Math.PI / 180),',
        '      txAbs',
        '    });',
        '  }',
        '  const pixels = new Uint8ClampedArray(rows * cols * 4);',
        '  const coverage = new Uint8Array(rows * cols);',
        '  for (let row = 0; row < rows; row++) {',
        '    const lat = latMax - row * latStep;',
        '    for (let col = 0; col < cols; col++) {',
        '      const lon = lonMin + col * lonStep;',
        '      const idx = row * cols + col;',
        '      const offset = idx * 4;',
        '      let bestMargin = -Infinity;',
        '      let coverCount = 0;',
        '      let endGround = null;',
        '      if (config.useTerrain) {',
        '        endGround = await getElevation(lat, lon, zoom);',
        '        if (endGround == null) {',
        '          pixels[offset + 3] = 0;',
        '          continue;',
        '        }',
        '      }',
        '      for (const origin of originEntries) {',
        '        const dx = (lon - origin.lon) * origin.lonScale;',
        '        const dy = (lat - origin.lat) * latScale;',
        '        const distance = Math.sqrt(dx * dx + dy * dy);',
        '        if (distance <= 1 || distance > renderRange) {',
        '          continue;',
        '        }',
        '        let rxAbs = (config.rxMsl != null) ? config.rxMsl : (config.useTerrain ? endGround + config.rxAgl : origin.txAbs);',
        '        let maxV = 0;',
        '        if (config.useTerrain) {',
        '          const samples = Math.max(2, Math.ceil(distance / config.sampleStep) + 1);',
        '          for (let i = 1; i < samples - 1; i++) {',
        '            const t = i / (samples - 1);',
        '            const sLat = origin.lat + (lat - origin.lat) * t;',
        '            const sLon = origin.lon + (lon - origin.lon) * t;',
        '            const elev = await getElevation(sLat, sLon, zoom);',
        '            if (elev == null) continue;',
        '            const lineElev = origin.txAbs + (rxAbs - origin.txAbs) * t;',
        '            const d1 = distance * t;',
        '            const d2 = distance * (1 - t);',
        '            let fresnel = 0;',
        '            if (config.fresnelFactor > 0) {',
        '              fresnel = config.fresnelFactor * Math.sqrt((lambda * d1 * d2) / (d1 + d2));',
        '            }',
        '            const obstruction = (elev - lineElev) - fresnel;',
        '            if (obstruction <= 0) continue;',
        '            const v = obstruction * Math.sqrt((2 * (d1 + d2)) / (lambda * d1 * d2));',
        '            if (v > maxV) maxV = v;',
        '          }',
        '        }',
        '        const extraLoss = maxV > 0 ? knifeEdgeLossFromV(maxV) : 0;',
        '        const pathLoss = fspl1mDb + (10 * config.pathLossExp * Math.log10(distance)) + extraLoss + clutterLossDb;',
        '        const margin = maxPathLossDb - pathLoss;',
        '        if (margin > 0) {',
        '          coverCount += 1;',
        '          if (margin > bestMargin) bestMargin = margin;',
        '        }',
        '      }',
        '      if (coverCount > 0) {',
        '        const strength = Math.min(1, bestMargin / 20);',
        '        if (coverCount >= 2) {',
        '          pixels[offset] = 34;',
        '          pixels[offset + 1] = 197;',
        '          pixels[offset + 2] = 94;',
        '        } else {',
        '          pixels[offset] = 239;',
        '          pixels[offset + 1] = 68;',
        '          pixels[offset + 2] = 68;',
        '        }',
        '        pixels[offset + 3] = config.fadeByMargin ? Math.round(255 * strength) : 255;',
        '        coverage[idx] = Math.min(255, coverCount);',
        '      } else {',
        '        pixels[offset + 3] = 0;',
        '      }',
        '    }',
        '    if (row % 10 === 0) {',
        '      self.postMessage({ type: "progress", token, row, rows });',
        '      await new Promise((resolve) => setTimeout(resolve, 0));',
        '    }',
        '  }',
        '    self.postMessage({',
        '      type: "result",',
        '      token,',
        '      width: cols,',
        '      height: rows,',
        '      bounds: { latMin, latMax, lonMin, lonMax },',
        '      latStep,',
        '      lonStep,',
        '      pixels: pixels.buffer,',
        '      coverage: coverage.buffer',
        '    }, [pixels.buffer, coverage.buffer]);',
        '  } catch (err) {',
        '    const message = (err && err.message) ? err.message : String(err);',
        '    self.postMessage({ type: "error", token, error: message });',
        '  }',
        '};'
      ].join('\n');

      const blob = new Blob([workerCode], { type: 'text/javascript' });
      propagationWorker = new Worker(URL.createObjectURL(blob));
      propagationWorker.onmessage = (event) => {
        const msg = event.data;
        if (!msg || msg.token !== propagationComputeToken) return;
        if (msg.type === 'progress') {
          const pct = Math.round((msg.row / Math.max(1, msg.rows)) * 100);
          setPropStatus(`Rendering: ${pct}%`);
          return;
        }
        if (msg.type === 'result') {
          const pixels = new Uint8ClampedArray(msg.pixels);
          const coverage = new Uint8Array(msg.coverage);
          const canvas = document.createElement('canvas');
          canvas.width = msg.width;
          canvas.height = msg.height;
          const ctx = canvas.getContext('2d');
          const imageData = new ImageData(pixels, msg.width, msg.height);
          ctx.putImageData(imageData, 0, 0);
          propagationRasterCanvas = canvas;
          const dataUrl = canvas.toDataURL('image/png');
          const bounds = [
            [msg.bounds.latMin, msg.bounds.lonMin],
            [msg.bounds.latMax, msg.bounds.lonMax]
          ];
          if (!propagationRaster) {
            propagationRaster = L.imageOverlay(dataUrl, bounds, { opacity: propagationLastConfig?.opacity ?? 0.2 }).addTo(propagationLayer);
          } else {
            propagationRaster.setUrl(dataUrl);
            propagationRaster.setBounds(bounds);
          }
          if (propagationRaster && propagationLastConfig) {
            propagationRaster.setOpacity(propagationLastConfig.opacity);
          }
          propagationRasterMeta = {
            latMin: msg.bounds.latMin,
            latMax: msg.bounds.latMax,
            lonMin: msg.bounds.lonMin,
            lonMax: msg.bounds.lonMax,
            latStep: msg.latStep,
            lonStep: msg.lonStep,
            rows: msg.height,
            cols: msg.width,
            coverage
          };
          propagationRenderInFlight = false;
          propagationNeedsRender = false;
          if (propagationOrigins.length) {
            updatePropagationStatusFromRaster();
          }
          return;
        }
        if (msg.type === 'error') {
          setPropStatus(`Render failed: ${msg.error || 'unknown error'}`);
          propagationRenderInFlight = false;
        }
      };
      return propagationWorker;
    }

    function renderPropagationRaster() {
      if (!propagationActive) return;
      const config = getPropagationConfig();
      if (!config) return;
      if (!propagationOrigins.length) {
        setPropStatus('Select a node or click the map to set a transmitter.');
        return;
      }
      if (propagationRenderInFlight) {
        setPropStatus('Render already in progress.');
        return;
      }
      const sensitivity = calcReceiverSensitivityDbm(
        PROP_DEFAULTS.bwHz,
        PROP_DEFAULTS.noiseFigureDb,
        PROP_DEFAULTS.snrMinDb
      );
      const maxPathLoss = config.autoRange
        ? (config.txPower - config.minRxDbm)
        : calcMaxPathLossDb(config.txPower, sensitivity, PROP_DEFAULTS.fadeMarginDb);
      const baseRange = calcRangeMeters(maxPathLoss, PROP_DEFAULTS.freqMHz, config.model.n, config.model.clutterLossDb);
      propagationBaseRange = baseRange;
      const renderRange = config.autoRange ? baseRange : (baseRange * config.rangeFactor);
      const originCount = propagationOrigins.length;
      const resolution = derivePropagationResolution(config, renderRange, originCount);
      propagationLastConfig = config;
      propagationOrigins.forEach((origin) => upsertPropagationOriginMarker(origin));
      updatePropagationSummary();
      propagationComputeToken += 1;
      propagationRenderInFlight = true;
      setPropStatus('Rendering: 0%');
      ensurePropagationWorker();
      propagationWorker.postMessage({
        type: 'render',
        token: propagationComputeToken,
        origins: propagationOrigins.map((origin) => ({ lat: origin.lat, lon: origin.lon })),
        renderRange,
        maxPathLossDb: maxPathLoss,
        fspl1mDb: calcFsplAt1mDb(PROP_DEFAULTS.freqMHz),
        freqMHz: PROP_DEFAULTS.freqMHz,
        config: {
          gridStep: resolution.gridStep,
          sampleStep: resolution.sampleStep,
          pathLossExp: config.model.n,
          clutterLossDb: config.model.clutterLossDb,
          useTerrain: config.terrain,
          fresnelFactor: PROP_DEFAULTS.fresnelFactor,
          txAgl: config.txAgl,
          rxAgl: config.rxAgl,
          txMsl: config.txMsl,
          rxMsl: config.rxMsl,
          fadeByMargin: config.fadeMargin
        }
      });
    }

    function setPropagationOrigin(latlng, id = null) {
      if (!latlng) return;
      const meta = id ? deviceMeta.get(id) : null;
      const lat = latlng.lat;
      const lon = latlng.lng ?? latlng.lon;
      const multi = isMultiOriginEnabled();
      if (!multi) {
        clearPropagationOrigins();
      }
      let origin = null;
      if (id) {
        origin = propagationOrigins.find(item => item.id === id) || null;
      }
      if (!origin && multi && !id) {
        origin = propagationOrigins.find(item => item.lat === lat && item.lon === lon) || null;
      }
      if (!origin) {
        origin = {
          lat,
          lon,
          id,
          key: id ? null : `manual-${Date.now()}-${propagationOriginSeq += 1}`,
          name: meta ? meta.name : null
        };
        propagationOrigins.push(origin);
      } else {
        origin.lat = lat;
        origin.lon = lon;
        origin.name = meta ? meta.name : origin.name;
      }
      upsertPropagationOriginMarker(origin);
      resetPropagationRaster();
      updatePropagationSummary();
      const label = propagationOrigins.length === 1 ? 'Origin set.' : `${propagationOrigins.length} origins set.`;
      markPropagationDirty(`${label} Click "Render prop" to calculate coverage.`);
    }

    function formatLastContact(tsSeconds) {
      if (!tsSeconds) return 'unknown';
      const dt = new Date(tsSeconds * 1000);
      return dt.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
      });
    }

    function makePopup(d) {
      const lastContact = formatLastContact(d.ts);
      const deviceLabel = d.device_id ? `${d.device_id.slice(0, 8)}…` : '';
      const title = d.name
        ? `<span class="popup-title">${d.name}</span><span class="popup-id">${deviceLabel}</span>`
        : `<span class="popup-title popup-id">${deviceLabel}</span>`;
      const role = resolveRole(d);
      const roleLabel = role === 'unknown' ? '' : role.charAt(0).toUpperCase() + role.slice(1);
      return `
        ${title}
        <span class="small">
          ${roleLabel ? `Role: ${roleLabel}<br/>` : ``}
          Location: ${d.lat.toFixed(6)}, ${d.lon.toFixed(6)}<br/>
          Last Contact: ${lastContact}<br/>
          ${d.rssi != null ? `RSSI: ${d.rssi}<br/>` : ``}
          ${d.snr != null ? `SNR: ${d.snr}<br/>` : ``}
        </span>
      `;
    }

    function upsertDevice(d, trail) {
      const id = d.device_id;
      const latlng = [d.lat, d.lon];
      const role = resolveRole(d);
      const style = markerStyleForRole(role);
      deviceMeta.set(id, { lat: d.lat, lon: d.lon, name: d.name });

      // marker
      if (!markers.has(id)) {
        const m = L.circleMarker(latlng, style).addTo(nodeLayer);
        m.bindPopup(makePopup(d), {
          maxWidth: 260,
          maxHeight: 320,
          autoPan: true,
          keepInView: true,
          autoPanPadding: [18, 18]
        });
        m.on('click', (ev) => {
          const original = ev.originalEvent;
          if (original && original.shiftKey) {
            if (!losActive) {
              setLosActive(true);
            }
            handleLosPoint(m.getLatLng());
            m.closePopup();
            original.preventDefault();
            original.stopPropagation();
            L.DomEvent.stop(ev);
            return;
          }
          if (propagationActive) {
            setPropagationOrigin(m.getLatLng(), id);
            m.openPopup();
            if (original) {
              original.preventDefault();
              original.stopPropagation();
            }
            L.DomEvent.stop(ev);
          }
        });
        markers.set(id, m);
      } else {
        const m = markers.get(id);
        m.setLatLng(latlng);
        m.setPopupContent(makePopup(d));
        if (m.setStyle) m.setStyle(style);
      }

      // trail polyline (skip companions)
      if (role !== 'companion' && Array.isArray(trail) && trail.length >= 2) {
        const points = trail.map(p => [p[0], p[1]]);
        if (!polylines.has(id)) {
          const pl = L.polyline(points, {
            color: '#38bdf8',
            weight: 3,
            opacity: 0.85,
            className: 'trail-animated'
          }).addTo(nodeLayer);
          polylines.set(id, pl);
        } else {
          const pl = polylines.get(id);
          pl.setLatLngs(points);
          if (pl.setStyle) {
            pl.setStyle({ color: '#38bdf8', weight: 3, opacity: 0.85 });
          }
        }
      } else if (polylines.has(id) && role === 'companion') {
        nodeLayer.removeLayer(polylines.get(id));
        polylines.delete(id);
      }

      setStats();
      if (propagationActive && propagationOrigins.length) {
        const origin = propagationOrigins.find(item => item.id === id);
        if (origin) {
          origin.lat = d.lat;
          origin.lon = d.lon;
          origin.name = d.name || origin.name;
          upsertPropagationOriginMarker(origin);
          resetPropagationRaster();
          updatePropagationSummary();
          markPropagationDirty('Origin moved. Click "Render prop" to update.');
          return;
        }
        if (propagationRasterMeta && !propagationNeedsRender) {
          updatePropagationStatusFromRaster();
        }
      }
    }

    function removeDevices(ids) {
      ids.forEach(id => {
        if (markers.has(id)) {
          nodeLayer.removeLayer(markers.get(id));
          markers.delete(id);
        }
        if (polylines.has(id)) {
          nodeLayer.removeLayer(polylines.get(id));
          polylines.delete(id);
        }
        deviceMeta.delete(id);
      });
      setStats();
      if (propagationActive && propagationOrigins.length) {
        const removed = propagationOrigins.filter(origin => origin.id && ids.includes(origin.id));
        if (removed.length) {
          removed.forEach((origin) => {
            const key = getPropagationOriginKey(origin);
            if (key && propagationOriginMarkers.has(key)) {
              propagationLayer.removeLayer(propagationOriginMarkers.get(key));
              propagationOriginMarkers.delete(key);
            }
          });
          propagationOrigins = propagationOrigins.filter(origin => !(origin.id && ids.includes(origin.id)));
          resetPropagationRaster();
          updatePropagationSummary();
          if (!propagationOrigins.length) {
            setPropStatus('Select a node or click the map to set a transmitter.');
          } else {
            markPropagationDirty('Origin removed. Click "Render prop" to update.');
          }
        } else {
          if (propagationRasterMeta && !propagationNeedsRender) {
            updatePropagationStatusFromRaster();
          }
        }
      }
    }

    function removeRoutes(ids) {
      ids.forEach(id => {
        const entry = routeLines.get(id);
        if (!entry) return;
        if (entry.timeout) clearTimeout(entry.timeout);
        routeLayer.removeLayer(entry.line);
        routeLines.delete(id);
      });
      setStats();
    }

    function refreshHeatLayer() {
      const now = Date.now();
      const cutoff = now - HEAT_TTL_MS;
      const filtered = heatPoints.filter(p => p.ts >= cutoff);
      heatPoints.length = 0;
      heatPoints.push(...filtered);
      heatLayer.setLatLngs(heatPoints.map(p => [p.lat, p.lon, p.weight]));
    }

    function addHeatPoints(points, tsSeconds, payloadType) {
      if (!Array.isArray(points) || points.length < 1) return;
      if (Number(payloadType) === 4) return; // skip adverts for route-based heat
      const ts = (tsSeconds ? tsSeconds * 1000 : Date.now());
      points.forEach(p => {
        heatPoints.push({ lat: p[0], lon: p[1], ts, weight: 0.7 });
      });
      refreshHeatLayer();
    }

    function seedHeat(items) {
      if (!Array.isArray(items)) return;
      heatPoints.length = 0;
      items.forEach(item => {
        if (!Array.isArray(item) || item.length < 3) return;
        heatPoints.push({
          lat: item[0],
          lon: item[1],
          ts: item[2] * 1000,
          weight: item[3] != null ? item[3] : 0.7
        });
      });
      refreshHeatLayer();
    }

    function upsertRoute(r, skipHeat = false) {
      if (!r || !Array.isArray(r.points) || r.points.length < 2) return;
      const id = r.id || `route-${Date.now()}-${Math.random()}`;
      const points = r.points.map(p => [p[0], p[1]]);
      const routeMode = r.route_mode || 'path';
      const isFanout = routeMode === 'fanout';
      const payloadType = Number(r.payload_type);
      const isAdvert = payloadType === 4;
      const style = {
        color: isAdvert ? '#2ecc71' : (isFanout ? '#2b8cff' : '#ff7a1a'),
        weight: isFanout ? 4 : 5,
        opacity: isFanout ? 0.85 : 0.9,
        lineCap: 'butt',
        lineJoin: 'miter'
      };
      if (!isFanout) {
        style.dashArray = isAdvert ? '4 10' : '8 14';
      }

      let entry = routeLines.get(id);
      if (!entry) {
        const line = L.polyline(points, style).addTo(routeLayer);
        entry = { line, timeout: null };
        routeLines.set(id, entry);
      } else {
        entry.line.setLatLngs(points);
        entry.line.setStyle(style);
      }
      const lineEl = entry.line.getElement();
      if (lineEl) {
        lineEl.classList.add('route-animated');
      }

      if (entry.timeout) clearTimeout(entry.timeout);
      if (r.expires_at) {
        const ms = Math.max(1000, (r.expires_at * 1000) - Date.now());
        entry.timeout = setTimeout(() => removeRoutes([id]), ms);
      }

      if (!skipHeat) {
        addHeatPoints(points, r.ts, r.payload_type);
      }
      setStats();
    }

    async function initialSnapshot() {
      try {
        const res = await fetch('/snapshot');
        const snap = await res.json();
        if (snap.devices) {
          for (const [id, d] of Object.entries(snap.devices)) {
            const trail = snap.trails ? snap.trails[id] : null;
            upsertDevice(d, trail);
          }
        }
        if (Array.isArray(snap.heat)) {
          seedHeat(snap.heat);
        }
        if (Array.isArray(snap.routes)) {
          snap.routes.forEach(r => upsertRoute(r, true));
        }
      } catch (e) {
        console.warn("snapshot failed", e);
      }
    }

    function connectWS() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const ws = new WebSocket(`${proto}://${location.host}/ws`);

      ws.onopen = () => console.log("ws connected");
      ws.onclose = () => {
        console.log("ws disconnected, retrying...");
        setTimeout(connectWS, 1500);
      };

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);

        if (msg.type === "snapshot") {
          // same shape as /snapshot
          for (const [id, d] of Object.entries(msg.devices || {})) {
            const trail = msg.trails ? msg.trails[id] : null;
            upsertDevice(d, trail);
          }
          if (Array.isArray(msg.heat)) {
            seedHeat(msg.heat);
          }
          if (Array.isArray(msg.routes)) {
            msg.routes.forEach(r => upsertRoute(r, true));
          }
          return;
        }

        if (msg.type === "update") {
          upsertDevice(msg.device, msg.trail);
          return;
        }

        if (msg.type === "route") {
          upsertRoute(msg.route);
          return;
        }

        if (msg.type === "route_remove") {
          removeRoutes(msg.route_ids || []);
          return;
        }

        if (msg.type === "stale") {
          removeDevices(msg.device_ids || []);
          return;
        }
      };
    }

    async function runLosCheck() {
      if (losPoints.length < 2) return;
      const [a, b] = losPoints;
      setLosStatus('LOS: calculating...');
      const params = new URLSearchParams({
        lat1: a.lat.toFixed(6),
        lon1: a.lng.toFixed(6),
        lat2: b.lat.toFixed(6),
        lon2: b.lng.toFixed(6)
      });
      try {
        const res = await fetch(`/los?${params.toString()}`);
        const data = await res.json();
        if (!data.ok) {
          setLosStatus(`LOS: ${data.error || 'failed'}`);
          if (losLine) {
            losLine.setStyle({ color: '#9ca3af', weight: 4, opacity: 0.8, dashArray: '6 10' });
          }
          return;
        }
        const blocked = data.blocked;
        let distance = '';
        if (data.distance_m != null) {
          const meters = Number(data.distance_m);
          if (!Number.isNaN(meters)) {
            distance = meters >= 1000
              ? `${(meters / 1000).toFixed(2)} km`
              : `${Math.round(meters)} m`;
          }
        }
        const obstruction = blocked ? `blocked (+${data.max_obstruction_m}m)` : 'clear';
        let statusText = `LOS: ${distance} • ${obstruction}`;
        if (losSuggestion) {
          losLayer.removeLayer(losSuggestion);
          losSuggestion = null;
        }
        if (data.suggested) {
          const s = data.suggested;
          const label = s.clear ? 'Relay (clear)' : 'Relay (blocked)';
          const color = s.clear ? '#22c55e' : '#f59e0b';
          losSuggestion = L.circleMarker([s.lat, s.lon], {
            radius: 6,
            color,
            fillColor: color,
            fillOpacity: 0.9,
            weight: 2
          }).addTo(losLayer);
          losSuggestion.bindTooltip(`${label}<br/>${s.lat}, ${s.lon}`, { direction: 'top' });
          statusText += s.clear ? ' • relay suggested' : ' • relay maybe';
        }
        setLosStatus(statusText);
        if (losLine) {
          losLine.setStyle({
            color: blocked ? '#ef4444' : '#22c55e',
            weight: 5,
            opacity: 0.9,
            dashArray: blocked ? '4 10' : null
          });
        }
      } catch (err) {
        console.warn('los failed', err);
        setLosStatus('LOS: error');
      }
    }

    function handleLosPoint(latlng) {
      if (losPoints.length >= 2) {
        clearLos();
      }
      losPoints.push(latlng);
      L.circleMarker(latlng, {
        radius: 5,
        color: '#fbbf24',
        fillColor: '#fbbf24',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(losLayer);

      if (losPoints.length === 1) {
        setLosStatus('LOS: select second point');
        return;
      }
      if (losPoints.length === 2) {
        losLine = L.polyline([losPoints[0], losPoints[1]], {
          color: '#9ca3af',
          weight: 4,
          opacity: 0.8,
          dashArray: '6 10'
        }).addTo(losLayer);
        runLosCheck();
      }
    }

    initialSnapshot();
    connectWS();
    setStats();
    setInterval(refreshHeatLayer, 15000);

    const legendToggle = document.getElementById('legend-toggle');
    const hud = document.querySelector('.hud');
    if (legendToggle && hud) {
      const storedLegend = localStorage.getItem('meshmapLegendCollapsed');
      if (storedLegend === 'true') {
        hud.classList.add('legend-collapsed');
        legendToggle.textContent = 'Show legend';
      }
      legendToggle.addEventListener('click', () => {
        const collapsed = hud.classList.toggle('legend-collapsed');
        legendToggle.textContent = collapsed ? 'Show legend' : 'Hide legend';
        localStorage.setItem('meshmapLegendCollapsed', collapsed ? 'true' : 'false');
      });
    }

    const mapToggle = document.getElementById('map-toggle');
    const topoToggle = document.getElementById('topo-toggle');
    function setBaseLayer(name) {
      if (map.hasLayer(lightTiles)) map.removeLayer(lightTiles);
      if (map.hasLayer(darkTiles)) map.removeLayer(darkTiles);
      if (map.hasLayer(topoTiles)) map.removeLayer(topoTiles);
      if (name === 'dark') {
        map.addLayer(darkTiles);
      } else if (name === 'topo') {
        map.addLayer(topoTiles);
      } else {
        map.addLayer(lightTiles);
      }
      baseLayer = name;
      localStorage.setItem('meshmapBaseLayer', baseLayer);
      if (mapToggle) {
        mapToggle.textContent = baseLayer === 'dark' ? 'Light map' : 'Dark map';
      }
      if (topoToggle) {
        topoToggle.textContent = baseLayer === 'topo' ? 'Standard map' : 'Topo map';
      }
    }

    if (mapToggle) {
      mapToggle.addEventListener('click', () => {
        setBaseLayer(baseLayer === 'dark' ? 'light' : 'dark');
      });
    }
    if (topoToggle) {
      topoToggle.addEventListener('click', () => {
        setBaseLayer(baseLayer === 'topo' ? 'light' : 'topo');
      });
    }
    setBaseLayer(baseLayer);

    const losToggle = document.getElementById('los-toggle');
    if (losToggle) {
      losToggle.addEventListener('click', () => {
        setLosActive(!losActive);
      });
    }

    const nodesToggle = document.getElementById('nodes-toggle');
    if (nodesToggle) {
      const storedNodes = localStorage.getItem('meshmapNodesVisible');
      if (storedNodes !== null) {
        setNodesVisible(storedNodes === 'true');
      } else {
        setNodesVisible(true);
      }
      nodesToggle.addEventListener('click', () => {
        setNodesVisible(!nodesVisible);
        localStorage.setItem('meshmapNodesVisible', nodesVisible ? 'true' : 'false');
      });
    }

    const propToggle = document.getElementById('prop-toggle');
    const propTxInput = document.getElementById('prop-txpower');
    const propOpacityInput = document.getElementById('prop-opacity');
    const propModelSelect = document.getElementById('prop-model');
    const propTerrainInput = document.getElementById('prop-terrain');
    const propTxAglInput = document.getElementById('prop-tx-agl');
    const propRxAglInput = document.getElementById('prop-rx-agl');
    const propTxMslInput = document.getElementById('prop-tx-msl');
    const propRxMslInput = document.getElementById('prop-rx-msl');
    const propMinRxInput = document.getElementById('prop-min-rx');
    const propAutoRangeInput = document.getElementById('prop-auto-range');
    const propMultiOriginInput = document.getElementById('prop-multi-origin');
    const propFadeMarginInput = document.getElementById('prop-fade-margin');
    const propClearOriginsButton = document.getElementById('prop-clear-origins');
    const propAutoResInput = document.getElementById('prop-auto-res');
    const propMaxCellsInput = document.getElementById('prop-max-cells');
    const propGridInput = document.getElementById('prop-grid');
    const propSampleInput = document.getElementById('prop-sample');
    const propRangeFactorInput = document.getElementById('prop-range-factor');
    const propRenderButton = document.getElementById('prop-render');

    if (propTxInput) {
      const storedTx = localStorage.getItem('meshmapPropTxPower');
      if (storedTx !== null) propTxInput.value = storedTx;
      propTxInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropTxPower', propTxInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propOpacityInput) {
      const storedOpacity = localStorage.getItem('meshmapPropOpacity');
      if (storedOpacity !== null) propOpacityInput.value = storedOpacity;
      propOpacityInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropOpacity', propOpacityInput.value);
        if (propagationRaster) {
          propagationRaster.setOpacity(Number(propOpacityInput.value));
        }
        if (propagationLastConfig) {
          propagationLastConfig.opacity = Number(propOpacityInput.value);
        }
      });
    }

    if (propModelSelect) {
      const storedModel = localStorage.getItem('meshmapPropModel');
      if (storedModel && PROP_MODELS[storedModel]) {
        propModelSelect.value = storedModel;
      }
      propModelSelect.addEventListener('change', () => {
        localStorage.setItem('meshmapPropModel', propModelSelect.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propTerrainInput) {
      const storedTerrain = localStorage.getItem('meshmapPropTerrain');
      if (storedTerrain !== null) propTerrainInput.checked = storedTerrain === 'true';
      propTerrainInput.addEventListener('change', () => {
        localStorage.setItem('meshmapPropTerrain', propTerrainInput.checked ? 'true' : 'false');
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propTxAglInput) {
      const storedTxAgl = localStorage.getItem('meshmapPropTxAgl');
      if (storedTxAgl !== null) propTxAglInput.value = storedTxAgl;
      propTxAglInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropTxAgl', propTxAglInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propRxAglInput) {
      const storedRxAgl = localStorage.getItem('meshmapPropRxAgl');
      if (storedRxAgl !== null) propRxAglInput.value = storedRxAgl;
      propRxAglInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropRxAgl', propRxAglInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propTxMslInput) {
      const storedTxMsl = localStorage.getItem('meshmapPropTxMsl');
      if (storedTxMsl !== null) propTxMslInput.value = storedTxMsl;
      propTxMslInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropTxMsl', propTxMslInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propRxMslInput) {
      const storedRxMsl = localStorage.getItem('meshmapPropRxMsl');
      if (storedRxMsl !== null) propRxMslInput.value = storedRxMsl;
      propRxMslInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropRxMsl', propRxMslInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propMinRxInput) {
      const storedMinRx = localStorage.getItem('meshmapPropMinRx');
      if (storedMinRx !== null) propMinRxInput.value = storedMinRx;
      propMinRxInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropMinRx', propMinRxInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propAutoRangeInput) {
      const storedAutoRange = localStorage.getItem('meshmapPropAutoRange');
      if (storedAutoRange !== null) propAutoRangeInput.checked = storedAutoRange === 'true';
      propAutoRangeInput.addEventListener('change', () => {
        localStorage.setItem('meshmapPropAutoRange', propAutoRangeInput.checked ? 'true' : 'false');
        if (propRangeFactorInput) {
          propRangeFactorInput.disabled = propAutoRangeInput.checked;
        }
        updatePropagationSummary();
        markPropagationDirty();
      });
      if (propRangeFactorInput) {
        propRangeFactorInput.disabled = propAutoRangeInput.checked;
      }
    }

    if (propMultiOriginInput) {
      const storedMulti = localStorage.getItem('meshmapPropMultiOrigin');
      if (storedMulti !== null) propMultiOriginInput.checked = storedMulti === 'true';
      propMultiOriginInput.addEventListener('change', () => {
        localStorage.setItem('meshmapPropMultiOrigin', propMultiOriginInput.checked ? 'true' : 'false');
        if (!propMultiOriginInput.checked && propagationOrigins.length > 1) {
          const first = propagationOrigins[0];
          clearPropagationOrigins();
          propagationOrigins = [first];
          upsertPropagationOriginMarker(first);
          resetPropagationRaster();
          updatePropagationSummary();
          markPropagationDirty('Multi-origin disabled. Keeping first origin only.');
        } else {
          markPropagationDirty();
          if (propagationActive && propMultiOriginInput.checked && !propagationOrigins.length) {
            setPropStatus('Multi-origin enabled. Click nodes or the map to add transmitters.');
          }
        }
      });
    }

    if (propFadeMarginInput) {
      const storedFade = localStorage.getItem('meshmapPropFadeMargin');
      if (storedFade !== null) propFadeMarginInput.checked = storedFade === 'true';
      propFadeMarginInput.addEventListener('change', () => {
        localStorage.setItem('meshmapPropFadeMargin', propFadeMarginInput.checked ? 'true' : 'false');
        markPropagationDirty();
      });
    }

    if (propClearOriginsButton) {
      propClearOriginsButton.addEventListener('click', () => {
        clearPropagationOrigins();
        resetPropagationRaster();
        setPropStatus('Select a node or click the map to set a transmitter.');
        updatePropagationSummary();
      });
    }

    if (propAutoResInput) {
      const storedAutoRes = localStorage.getItem('meshmapPropAutoRes');
      if (storedAutoRes !== null) propAutoResInput.checked = storedAutoRes === 'true';
      propAutoResInput.addEventListener('change', () => {
        localStorage.setItem('meshmapPropAutoRes', propAutoResInput.checked ? 'true' : 'false');
        if (propMaxCellsInput) {
          propMaxCellsInput.disabled = !propAutoResInput.checked;
        }
        updatePropagationSummary();
        markPropagationDirty();
      });
      if (propMaxCellsInput) {
        propMaxCellsInput.disabled = !propAutoResInput.checked;
      }
    }

    if (propMaxCellsInput) {
      const storedMaxCells = localStorage.getItem('meshmapPropMaxCells');
      if (storedMaxCells !== null) propMaxCellsInput.value = storedMaxCells;
      propMaxCellsInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropMaxCells', propMaxCellsInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propGridInput) {
      const storedGrid = localStorage.getItem('meshmapPropGrid');
      if (storedGrid !== null) propGridInput.value = storedGrid;
      propGridInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropGrid', propGridInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propSampleInput) {
      const storedSample = localStorage.getItem('meshmapPropSample');
      if (storedSample !== null) propSampleInput.value = storedSample;
      propSampleInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropSample', propSampleInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propRangeFactorInput) {
      const storedRange = localStorage.getItem('meshmapPropRangeFactor');
      if (storedRange !== null) propRangeFactorInput.value = storedRange;
      propRangeFactorInput.addEventListener('input', () => {
        localStorage.setItem('meshmapPropRangeFactor', propRangeFactorInput.value);
        updatePropagationSummary();
        markPropagationDirty();
      });
    }

    if (propRenderButton) {
      propRenderButton.addEventListener('click', () => {
        renderPropagationRaster();
      });
    }

    if (propToggle) {
      propToggle.addEventListener('click', () => {
        setPropActive(!propagationActive);
        if (propagationActive) {
          updatePropagationSummary();
          if (propagationOrigins.length) {
            const label = propagationOrigins.length === 1 ? 'Origin set.' : `${propagationOrigins.length} origins set.`;
            setPropStatus(`${label} Click "Render prop" to calculate coverage.`);
          }
        }
      });
    }

    map.on('click', (ev) => {
      if (losActive) {
        handleLosPoint(ev.latlng);
        return;
      }
      if (propagationActive) {
        setPropagationOrigin(ev.latlng);
      }
    });
  </script>
</body>
</html>
